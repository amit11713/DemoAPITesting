# Reqnroll BDD Framework & Parallel Scenario Execution

This document explains the implementation of Behavior-Driven Development (BDD) with Reqnroll and scenario-level parallel execution in the DemoAPITesting project.

## Overview

The DemoAPITesting project has been enhanced with Reqnroll (a .NET implementation of Cucumber) to support BDD testing practices. This approach allows writing test scenarios in Gherkin syntax that is understandable to both technical and non-technical stakeholders, while also enabling significant performance improvements through parallel scenario execution.

## Key Components

### 1. Reqnroll Feature Files

**Location:** `Features/` directory
- Written in Gherkin syntax (Given-When-Then)
- Define test scenarios in natural language
- Provide living documentation of application behavior
- Example: `Features/Authentication.feature`

**Sample Feature File:**@Authentication @parallel
Feature: Authentication
    As an API client
    I want to authenticate with the Restful Booker API
    So that I can perform authenticated operations

@parallel
Scenario: Successful authentication with valid credentials
    Given I have valid username and password
    When I attempt to create an authentication token
    Then I should receive a valid non-empty token

@parallel
Scenario: Failed authentication with invalid credentials
    Given I have invalid username and password
    When I attempt to create an authentication token
    Then I should receive a "Bad credentials" error message

### 2. Auto-Generated Feature Code Files

**Location:** `Features/` directory (e.g., `Features/Authentication.feature.cs`)

Reqnroll automatically generates `.feature.cs` files for each `.feature` file in your project. These auto-generated files serve several important purposes:

- **Test Runner Integration:** They translate human-readable Gherkin scenarios into executable C# code that NUnit can run.
- **Generated Test Methods:** For each scenario in your `.feature` file, the generated code creates a corresponding test method with proper NUnit attributes.
- **Test Lifecycle Management:** The file contains methods to handle test setup, execution, and teardown that integrate with both NUnit and Reqnroll.
- **Parallel Execution Support:** The generated code applies necessary attributes for parallel execution (`[Parallelizable]`, `[FixtureLifeCycle]`).

**Key Points:**
- These files are automatically updated whenever:
  - You modify the original `.feature` file
  - You rebuild your project with Reqnroll tooling enabled
  - You use the Reqnroll Visual Studio extension which regenerates these files on save
- **Do not modify** these files manually as they are overwritten during the build process
- The file header explicitly warns about this with:// <auto-generated>
//    Changes to this file may cause incorrect behavior and will be lost if
//      the code is regenerated.
//  </auto-generated>

### 3. Parallel Execution Configuration

The project uses two configuration files to control parallel execution:

**File:** `reqnroll.json`{
  "reqnroll": {
    "runtime": {
      "parallelExecutionMode": "scenario",
      "maxThreadCount": 4,
      "stopAtFirstError": false
    },
    "trace": {
      "traceSuccessfulSteps": true,
      "traceTimings": true,
      "stepDefinitionSkeletonStyle": "AsyncAwait"
    }
  }
}
**File:** `NUnit.Runners.reqnroll.json`{
  "reqnroll": {
    "unitTestProvider": {
      "name": "NUnit"
    },
    "runtime": {
      "stopAtFirstError": false,
      "testThreadCount": 4
    }
  }
}
**Key Configuration Elements:**
- `parallelExecutionMode`: Set to "scenario" to run individual scenarios in parallel
- `maxThreadCount`/`testThreadCount`: Maximum number of concurrent scenarios (4 in this configuration)
- `stopAtFirstError`: Set to false to continue execution of other scenarios if one fails
- `unitTestProvider`: Specifies NUnit as the test runner

**NUnit Assembly Configuration:** `AssemblyInfo.cs`// Enable parallel execution for fixtures and for tests within fixtures.
[assembly: NUnit.Framework.Parallelizable(NUnit.Framework.ParallelScope.All)]

// Set number of worker threads
[assembly: NUnit.Framework.LevelOfParallelism(4)]

### 4. Thread-Safe Dependency Injection

**Location:** `Tests/Support/ServiceRegistration.cs`

The `ServiceRegistration` class implements Reqnroll's `[ScenarioDependencies]` pattern to create and register services for each scenario:
public static class ServiceRegistration
{
    [ScenarioDependencies]
    public static IServiceCollection CreateServices()
    {
        var services = new ServiceCollection();

        // Load configuration from appsettings.json
        var configuration = new ConfigurationBuilder()
            .SetBasePath(Directory.GetCurrentDirectory())
            .AddJsonFile("appsettings.json", optional: false, reloadOnChange: true)
            .Build();

        services.AddSingleton<IConfiguration>(configuration);

        // Register ApiSettings from configuration
        var apiSettings = configuration.GetSection("ApiSettings").Get<ApiSettings>() ?? new ApiSettings();
        services.AddSingleton(apiSettings);

        // Configure logging and register the API client
        services.ConfigureLogging(configuration);
        services.AddScoped<IRestfulBookerClient, RestfulBookerClient>();

        return services;
    }
}
**Key Points:**
- The `[ScenarioDependencies]` attribute tells Reqnroll to use this method for building the dependency injection container
- Services are registered with appropriate lifetimes (`AddSingleton` vs `AddScoped`)
- Configuration is loaded from `appsettings.json`
- The API client is registered with `AddScoped` to ensure thread safety across parallel scenarios
- Note that the `[Binding]` attribute has been intentionally removed from this static class

### 5. Step Definitions with Constructor Injection

**Location:** `Tests/AuthenticationStepDefinitions.cs`
[Binding]
public class AuthenticationStepDefinitions
{
    private readonly ScenarioContext _scenarioContext;
    private readonly IRestfulBookerClient _client;
    private readonly ILogger<AuthenticationStepDefinitions> _logger;
    private readonly ApiSettings _apiSettings;

    // Reqnroll and the DI plugin will automatically inject these services.
    public AuthenticationStepDefinitions(
        ScenarioContext scenarioContext,
        IRestfulBookerClient client,
        ILogger<AuthenticationStepDefinitions> logger,
        ApiSettings apiSettings)
    {
        _scenarioContext = scenarioContext;
        _client = client;
        _logger = logger;
        _apiSettings = apiSettings;
    }

    [Given("I have valid username and password")]
    public void GivenIHaveValidUsernameAndPassword()
    {
        _logger.LogInformation("Setting up valid credentials");
        _scenarioContext.Set(_apiSettings.Username, "Username");
        _scenarioContext.Set(_apiSettings.Password, "Password");
    }

    [Given("I have invalid username and password")]
    public void GivenIHaveInvalidUsernameAndPassword()
    {
        _logger.LogInformation("Setting up invalid credentials");
        _scenarioContext.Set("invalidUsername", "Username");
        _scenarioContext.Set("invalidPassword", "Password");
    }

    [When("I attempt to create an authentication token")]
    public async Task WhenIAttemptToCreateAnAuthenticationToken()
    {
        _logger.LogInformation("Attempting to create authentication token");
        try
        {
            string user = _scenarioContext.Get<string>("Username");
            string pass = _scenarioContext.Get<string>("Password");
            string token = await _client.CreateTokenAsync(user, pass);
            _scenarioContext.Set(token, "Token");
        }
        catch (Exception ex)
        {
            _scenarioContext.Set(ex);
        }
    }

    [Then("I should receive a valid non-empty token")]
    public void ThenIShouldReceiveAValidNonEmptyToken()
    {
        _logger.LogInformation("Verifying valid token");
        Assert.That(_scenarioContext.TryGetValue("Token", out string token), Is.True, "Token was not found in the context.");
        Assert.That(token, Is.Not.Null.And.Not.Empty, "Token should not be empty.");
    }

    [Then("I should receive a {string} error message")]
    public void ThenIShouldReceiveAErrorMessage(string expectedErrorMessage)
    {
        _logger.LogInformation("Verifying error message: {ErrorMessage}", expectedErrorMessage);
        Assert.That(_scenarioContext.TryGetValue(out Exception ex), Is.True, "An exception was expected, but not found in the context.");
        Assert.That(ex.Message, Does.Contain(expectedErrorMessage), $"Exception message should contain '{expectedErrorMessage}'." );
    }
}
**Key Points:**
- The `[Binding]` attribute marks this as a step definition class
- Constructor injection is used to receive dependencies from the DI container
- `ScenarioContext` is used for storing and retrieving scenario-specific data
- Each step definition method is marked with `[Given]`, `[When]`, or `[Then]` attributes
- Structured logging with class context is implemented
- Assertions use NUnit's `Assert.That` pattern
- Note that the step definitions class is in namespace `ApiTestingProject.Tests.StepDefinitions`, not in the standard DemoAPITesting namespace

### 6. Scenario Context and Thread Safety

Thread-safe execution is ensured through several mechanisms:

1. **Scenario Context Isolation**: Each scenario has its own isolated `ScenarioContext` instance
2. **Scoped Service Registration**: Services are registered with the appropriate lifetime
3. **Instance-Per-Test Case**: The `[FixtureLifeCycle(LifeCycle.InstancePerTestCase)]` attribute ensures each scenario gets a fresh test fixture
4. **Parallel Tags**: `@parallel` tags are used to mark both individual scenarios and the entire feature that can run in parallel

**Example of the Feature Class with Parallel Configuration:**[NUnit.Framework.TestFixtureAttribute()]
[NUnit.Framework.DescriptionAttribute("Authentication")]
[NUnit.Framework.FixtureLifeCycleAttribute(NUnit.Framework.LifeCycle.InstancePerTestCase)]
[NUnit.Framework.CategoryAttribute("Authentication")]
[NUnit.Framework.CategoryAttribute("parallel")]
public partial class AuthenticationFeature
{
    // Generated test methods...
}
## Running Tests

Reqnroll scenarios can be run using the standard dotnet test command with filtering options:

**Run All Tests:**dotnet test
**Run Tests by Category:**dotnet test --filter Category=Authentication
**Run Tests with Specific Tags:**dotnet test --filter TestCategory=parallel
**Control Parallel Execution:**
- To adjust the number of parallel workers, modify the `maxThreadCount` value in `reqnroll.json`
- To temporarily disable parallelism, run with:dotnet test -- NUnit.NumberOfTestWorkers=1
## Benefits of Scenario-Level Parallelism

### 1. Improved Performance

- **Execution Speed:** Running scenarios in parallel significantly reduces the overall test execution time
- **Resource Utilization:** Better CPU utilization across multiple cores
- **Scaling:** Performance scales with available hardware resources

**Example Performance Comparison:**
- Sequential execution: ~45 seconds for all scenarios
- Parallel execution (4 threads): ~15-20 seconds (60-70% reduction)

### 2. Isolated Test Execution

- Each scenario runs in its own isolated context
- No shared state between scenarios due to `ScenarioContext` isolation
- Each scenario gets its own scoped service instances (e.g., `IRestfulBookerClient`)
- Prevents test interference and reduces flaky tests

### 3. Enhanced Maintainability

- Clean separation between scenario definitions and implementation
- Natural language scenarios improve test readability
- Structured approach for test organization
- Reusable step definitions across scenarios

## Technical Implementation Details

### 1. NUnit Integration

- Reqnroll integrates with NUnit as the test execution engine
- Uses `[FixtureLifeCycle(LifeCycle.InstancePerTestCase)]` for isolation
- Ensures each scenario gets a fresh environment

### 2. Thread Safety Mechanisms

- **Service Scoping:** `AddScoped<IRestfulBookerClient, RestfulBookerClient>` ensures each scenario gets its own client
- **Context Isolation:** `ScenarioContext` is thread-safe and isolated per scenario
- **Dependency Injection:** Constructor injection prevents static state
- **Category Tagging:** `[Category("parallel")]` and `@parallel` tags enable targeted execution of parallel-safe tests

### 3. Logging in Parallel Context

- Thread ID enrichment for identifying scenario logs
- Structured logging with class and method context
- Per-scenario isolation prevents log message interleaving

## Troubleshooting

### Common Issues

1. **State Leakage Between Scenarios**
   - **Symptom:** Intermittent test failures when running in parallel
   - **Solution:** Ensure no static state is used; store all state in `ScenarioContext`

2. **Authentication Token Issues**
   - **Symptom:** Unauthorized errors in some scenarios
   - **Solution:** Verify token handling in the steps and ensure tokens are stored in `ScenarioContext`

3. **Resource Contention**
   - **Symptom:** Timeouts or conflicts between scenarios
   - **Solution:** Adjust `maxThreadCount` based on system capabilities

### Debugging Tips

- Run specific test categories with filtering: `dotnet test --filter Category=Authentication`
- Temporarily disable parallelism: `dotnet test -- NUnit.NumberOfTestWorkers=1`
- Enable verbose logging in `reqnroll.json`
- Check thread IDs in logs to identify scenario context